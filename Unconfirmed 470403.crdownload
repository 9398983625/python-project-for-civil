# -*- coding: utf-8 -*-
"""Copy of Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TzeOBAO_AxoN3CuvEZVBk3qIPR0aF5EG
"""

# Beam Deflection Calculator Script
# Dependencies: numpy, matplotlib, scipy

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve

class Beam1D:
    def __init__(self, L, E, I, n_elem=100, support_type="simply_supported"):
        self.L = float(L)
        self.E = float(E)
        self.I = float(I)
        self.n_elem = int(max(2, n_elem))
        self.n_nodes = self.n_elem + 1
        self.x = np.linspace(0, self.L, self.n_nodes)
        self.ndof = 2 * self.n_nodes
        self.K = lil_matrix((self.ndof, self.ndof), dtype=float)
        self.F = np.zeros(self.ndof, dtype=float)
        self.Le = self.L / self.n_elem
        self.load_notes = []
        self._assemble_stiffness()
        self.support_type = support_type
        self.fixed_dofs = self._build_bcs(support_type)
        self.U = None

    def _element_stiffness(self):
        L = self.Le
        EI = self.E * self.I
        k = EI / (L**3) * np.array([
            [ 12,   6*L,  -12,   6*L],
            [ 6*L, 4*L**2, -6*L, 2*L**2],
            [-12,  -6*L,   12,  -6*L],
            [ 6*L, 2*L**2, -6*L, 4*L**2]
        ], dtype=float)
        return k

    def _assemble_stiffness(self):
        k = self._element_stiffness()
        for e in range(self.n_elem):
            dofs = np.array([2*e, 2*e+1, 2*(e+1), 2*(e+1)+1])
            for i in range(4):
                for j in range(4):
                    self.K[dofs[i], dofs[j]] += k[i, j]

    def _build_bcs(self, support_type):
        fixed = []
        if support_type == "simply_supported":
            fixed += [0, 2*(self.n_nodes-1)]  # w(0)=0, w(L)=0
        elif support_type == "cantilever":
            fixed += [0, 1]  # w(0)=0, theta(0)=0
        else:
            raise ValueError("Unsupported support type.")
        return sorted(fixed)

    def add_udl(self, q, a=0.0, b=None):
        if b is None: b = self.L
        a = max(0.0, min(self.L, a))
        b = max(0.0, min(self.L, b))
        if b <= a: return
        self._add_uvl_segment(a, b, float(q), float(q))
        self.load_notes.append(f"UDL q={q} N/m over [{a}, {b}] m")

    def add_uvl(self, qa, qb, a=0.0, b=None):
        if b is None: b = self.L
        a = max(0.0, min(self.L, a))
        b = max(0.0, min(self.L, b))
        if b <= a: return
        self._add_uvl_segment(a, b, float(qa), float(qb))
        self.load_notes.append(f"UVL qa={qa}→qb={qb} N/m over [{a}, {b}] m")

    def _add_uvl_segment(self, a, b, qa, qb):
        for e in range(self.n_elem):
            xe0 = self.x[e]; xe1 = self.x[e+1]
            seg_a = max(a, xe0); seg_b = min(b, xe1)
            if seg_b <= seg_a: continue
            L = xe1 - xe0
            if b == a:
                q0 = qa; q1 = qb
            else:
                q0 = qa + (qb-qa)*(xe0 - a)/(b - a)
                q1 = qa + (qb-qa)*(xe1 - a)/(b - a)
            fe = np.array([
                (7*q0 + 3*q1)*L/20.0,
                (q0 + 2*q1)*L**2/60.0,
                (3*q0 + 7*q1)*L/20.0,
                -(2*q0 + q1)*L**2/60.0
            ], dtype=float)
            dofs = np.array([2*e, 2*e+1, 2*(e+1), 2*(e+1)+1])
            for i in range(4):
                self.F[dofs[i]] += fe[i]

    def add_point_load(self, P, x0):
        x0 = float(np.clip(x0, 0.0, self.L))
        node = int(np.round(x0 / self.Le))
        node = min(max(node, 0), self.n_nodes-1)
        self.F[2*node] += float(P)
        self.load_notes.append(f"Point load P={P} N at x={x0:.4f} m (snapped to node {node} at x={self.x[node]:.4f} m)")

    def add_point_moment(self, M, x0):
        x0 = float(np.clip(x0, 0.0, self.L))
        node = int(np.round(x0 / self.Le))
        node = min(max(node, 0), self.n_nodes-1)
        self.F[2*node+1] += float(M)
        self.load_notes.append(f"Point moment M={M} N·m at x={x0:.4f} m (snapped to node {node} at x={self.x[node]:.4f} m)")

    def solve(self):
        K = self.K.tocsr()
        F = self.F.copy()
        all_dofs = np.arange(self.ndof)
        free = np.setdiff1d(all_dofs, self.fixed_dofs)
        Kff = K[free][:, free]
        Kfc = K[free][:, self.fixed_dofs]
        Fc = np.zeros(len(self.fixed_dofs))
        Ff = F[free] - Kfc @ Fc
        Uf = spsolve(Kff, Ff)
        U = np.zeros(self.ndof)
        U[free] = Uf
        U[self.fixed_dofs] = 0.0
        self.U = U
        return U

    def _second_derivative(self):
        w = self.U[0::2]
        dx = self.Le
        wpp = np.zeros_like(w)
        for i in range(1, len(w)-1):
            wpp[i] = (w[i-1] - 2*w[i] + w[i+1]) / (dx*dx)
        wpp[0] = (2*w[0] - 5*w[1] + 4*w[2] - w[3]) / (dx*dx)
        wpp[-1] = (2*w[-1] - 5*w[-2] + 4*w[-3] - w[-4]) / (dx*dx)
        return wpp

    def _third_derivative(self):
        w = self.U[0::2]
        dx = self.Le
        wppp = np.zeros_like(w)
        for i in range(2, len(w)-2):
            wppp[i] = (w[i-2] - 2*w[i-1] + 2*w[i+1] - w[i+2]) / (2*dx**3)
        wppp[0]  = (-5*w[0]  + 18*w[1] - 24*w[2] + 14*w[3] - 3*w[4]) / (2*dx**3)
        wppp[1]  = (-5*w[1]  + 18*w[2] - 24*w[3] + 14*w[4] - 3*w[5]) / (2*dx**3)
        wppp[-2] = ( 5*w[-2] - 18*w[-3] + 24*w[-4] - 14*w[-5] + 3*w[-6]) / (2*dx**3)
        wppp[-1] = ( 5*w[-1] - 18*w[-2] + 24*w[-3] - 14*w[-4] + 3*w[-5]) / (2*dx**3)
        return wppp

    def results(self):
        if self.U is None:
            raise RuntimeError("Call solve() first.")
        w = self.U[0::2]
        th = self.U[1::2]
        EI = self.E * self.I
        wpp = self._second_derivative()
        wppp = self._third_derivative()
        M = EI * wpp
        V = EI * wppp
        return self.x, w, th, M, V

    def plot_all(self, title_note=""):
        x, w, th, M, V = self.results()
        plt.figure()
        plt.plot(x, w); plt.xlabel("x (m)"); plt.ylabel("Deflection w (m)"); plt.title(f"Deflection Curve {title_note}"); plt.grid(True)
        plt.figure()
        plt.plot(x, M); plt.xlabel("x (m)"); plt.ylabel("Bending Moment M (N·m)"); plt.title(f"Bending Moment Diagram {title_note}"); plt.grid(True)
        plt.figure()
        plt.plot(x, V); plt.xlabel("x (m)"); plt.ylabel("Shear Force V (N)"); plt.title(f"Shear Force Diagram {title_note}"); plt.grid(True)
        plt.show()


def run_calculator(L, support_type, load_type, magnitude, load_position=None, segment=None, E=200e9, I=8e-6, n_elem=200):
    beam = Beam1D(L=L, E=E, I=I, n_elem=n_elem, support_type=support_type)
    if load_type == "udl":
        a, b = (segment if segment is not None else (0.0, L))
        beam.add_udl(q=float(magnitude), a=a, b=b)
    elif load_type == "uvl":
        a, b = (segment if segment is not None else (0.0, L))
        qa, qb = magnitude
        beam.add_uvl(qa=float(qa), qb=float(qb), a=a, b=b)
    elif load_type == "point":
        if load_position is None: load_position = L/2.0
        beam.add_point_load(P=float(magnitude), x0=float(load_position))
    elif load_type == "moment":
        if load_position is None: load_position = L/2.0
        beam.add_point_moment(M=float(magnitude), x0=float(load_position))
    else:
        raise ValueError("Unsupported load_type.")
    beam.solve()
    x, w, th, M, V = beam.results()
    beam.plot_all(title_note=f"({support_type}, {load_type})")
    max_defl = w[np.argmin(w)] if np.min(w) < 0 else w[np.argmax(w)]
    x_max = x[np.argmin(w)] if np.min(w) < 0 else x[np.argmax(w)]
    notes = "\\n".join(beam.load_notes)
    summary = (f"Support: {support_type}\\nLoad: {load_type}\\nDetails:\\n{notes}\\n"
               f"Max deflection: {max_defl:.6e} m at x={x_max:.3f} m\\nTip deflection (x=L): {w[-1]:.6e} m")
    print(summary)
    return {"x": x, "w": w, "theta": th, "M": M, "V": V, "summary": summary}


if __name__ == "__main__":
    # Example case; edit and run this script to try your own inputs.
    run_calculator(
        L=5.0,
        support_type="simply_supported",  # or "cantilever"
        load_type="udl",                  # "udl", "uvl", "point", or "moment"
        magnitude=8000.0,                 # N/m for udl; (qa,qb) for uvl; N for point; N·m for moment
        load_position=None,               # x for point/moment; ignored for udl/uvl full-span
        segment=None,                     # (a,b) for udl/uvl subspan; None for full span
        E=25e9,                           # Pa
        I=8e-6,                           # m^4
        n_elem=300
    )